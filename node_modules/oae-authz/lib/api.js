/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var Redis = require('oae-util/lib/redis');
var Telemetry = require('oae-telemetry').telemetry('authz');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;


/////////////////////////
// ROLES & PERMISSIONS //
/////////////////////////

/**
 * Determine the direct role assigned to a principal on a specified resource.
 * 
 * @param  {String}     principalId     The principal id. This can be a user or a group
 * @param  {String}     resourceId      The resource id. This can be a group as well.
 * @param  {Function}   callback        Standard callback function 
 * @param  {Object}     callback.err    An error that occurred, if any.
 * @param  {String}     callback.role   The role of the principal on the resource. If the principal has no role or there is an error performing the check, role will be null.
 */
var _getDirectRole = function(principalId, resourceId, callback) {
    _getDirectRoles([principalId], resourceId, function(err, roles) {
        if (err) {
            return callback(err);
        }

        return callback(null, roles[principalId]);
    });
};

/**
 * Determine the role assigned to the given principals directly on the specified resource instance.
 * 
 * @param   {String[]}     principalIds    Array of principal ids. These can be user or group ids
 * @param   {String}       resourceId      The resource id. This can be a group as well.
 * @param   {Function}     callback        Standard callback function
 * @param   {Object}       callback.err    An error that occurred, if any.
 * @param   {Object}       callback.roles  A hash keyed by principal id, with value set to the role they have directly on the resource. If the principal has no role or there is an error performing the check, role will be null.
 **/
var _getDirectRoles = function(principalIds, resourceId, callback) {
    Cassandra.runQuery('SELECT ? FROM AuthzMembers USING CONSISTENCY QUORUM WHERE resourceId = ?', [principalIds, resourceId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Aggregate the roles for the principals
        var roles = Cassandra.rowToHash(rows[0]);
        return callback(null, roles);
    });
};

/**
 * Given a principal and a resource, determine all the effective roles that the principal has on the resource, by virtue of direct
 * association and indirect group inheritance.
 *
 * @param  {String}       principalId       The principal id. This can be a user or a group
 * @param  {String}       resourceId        The resource id. This can be a group as well.
 * @param  {Function}     callback          Standard callback function
 * @param  {Object}       callback.err      An error that occurred, if any
 * @param  {String[]}     callback.roles    An array containing all the roles the principal has on the resource.
 */
var getAllRoles = module.exports.getAllRoles = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {code: 400, msg: 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getAllRoles(principalId, resourceId, callback);
};

/**
 * Given a principal and a resource, determine all the roles that the principal has on the resource, by virtue of direct association and
 * indirect group inheritance.
 *
 * @param   {String}       principalId     The principal id. This can be a user or a group
 * @param   {String}       resourceId      The resource id. This can be a group as well.
 * @param   {Function}     callback        Standard callback function
 * @param   {Object}       callback.err    An error that occurred, if any
 * @param   {String[]}     callback.roles  An array containing all the roles the principal has on the resource.
 */
var _getAllRoles = function(principalId, resourceId, callback) {
    var allRoles = [];
    // Get the direct role of the user
    _getDirectRole(principalId, resourceId, function(err, directRole) {
        if (err) {
            return callback(err);
        } else if (directRole) {
            allRoles.push(directRole);
        }

        // Get the groups that are directly associated to the resource
        _getResourceGroupMembers(resourceId, function(err, groups) {
            if (err) {
                return callback(err);
            }
            
            // Check whether any of these are part of the user's direct memberships
            var groupIds = _.keys(groups);
            if (groupIds.length === 0) {
                return callback(null, allRoles);
            } else {
                
                // Make sure that the user's memberships have been exploded
                checkGroupMembershipsForUser(principalId, groupIds, function(err, memberships) {
                    if (err) {
                        return callback(err);
                    }
        
                    // Add the roles of the matching groups
                    for (var m = 0; m < memberships.length; m++) {
                        if (!_.contains(allRoles, groups[memberships[m]])) {
                            allRoles.push(groups[memberships[m]]);
                        }
                    }
                    return callback(null, allRoles);
                });
            }
        });
    });
};

/**
 * Get all of the groups that are directly and indirectly associated to a resource.
 * 
 * @param   {String}       resourceId      The resource id. This can be a group as well.
 * @param   {Function}     callback        Standard callback function
 * @param   {Object}       callback.err    An error that occurred, if any
 * @param   {Object}       callback.roles  A JSON object where the keys are the group ids of the directly and indirectly associated groups and the values are the direct role of that p
 */
var _getResourceGroupMembers = function(resourceId, callback) {
    // Get the groups that are directly associated to the resource
    var start = AuthzConstants.principalTypes.GROUP + ':';
    var end = start + '|';
    Cassandra.runQuery('SELECT ? .. ? FROM AuthzMembers USING CONSISTENCY QUORUM WHERE resourceId = ?', [start, end, resourceId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // If no groups are associated to the content, we can just return
        var groupHierarchy = Cassandra.rowToHash(rows[0]);
        callback(null, groupHierarchy);
    });
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 * 
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {String}      role                The role to check
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var hasRole = module.exports.hasRole = function(principalId, resourceId, role, callback) {
    var validator = new Validator();
    validator.check(principalId, {code: 400, msg: 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided.'}).isResourceId();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalId, resourceId, role, callback);
};

/**
 * Determines whether or not a principal has any role directly or indirectly on a given resource.
 * 
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has a role on the resource
 */
var hasAnyRole = module.exports.hasAnyRole = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {code: 400, msg: 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _hasRole(principalId, resourceId, null, callback);
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 * 
 * @param  {String}       principalId         The principal id. This can be a user or a group.
 * @param  {String}       resourceId          The resource id. This can be a group as well
 * @param  {String}       role                The role to check. If the role is null, we check for any role
 * @param  {Function}     callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}       callback.err        An error that occurred, if any
 * @param  {Boolean}      callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var _hasRole = function(principalId, resourceId, role, callback) {
    // Check for a direct role first
    _getDirectRole(principalId, resourceId, function(err, directRole) {
        if (err) {
            return callback(err);
        } else if (directRole && (role === null || directRole === role)) {
            return callback(null, true);
        }
        
        // If no direct role assignment is found, we try to find a role through an indirect membership
        getAllRoles(principalId, resourceId, function(err, roles) {
            if (err) {
                return callback(err);
            }
            
            // If a role is found and we are just looking for any role
            if (roles.length > 0 && role === null) {
                return callback(null, true);
            // If we are looking for a specific role and that specific role is present
            } else if (_.contains(roles, role)) {
                return callback(null, true);
            // If the specified role cannot be found
            } else {
                callback(null, false);
            }
        });
    });
};

/**
 * Assign one or multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}          resourceId      The resource id.
 * @param  {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}        callback        Standard callback function
 * @param  {Object}          callback.err    Error object, containing the error message
 */
var updateRoles = module.exports.updateRoles = function(resourceId, changes, callback) {
    var validator = new Validator();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided.'}).isResourceId();
    var roleChanges = _.keys(changes);
    validator.check(roleChanges.length, {code: 400, msg: 'At least one role change needs to be applied'}).min(1);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        validator.check(principalId, {code: 400, msg: 'Invalid principal id specified: ' + principalId}).isPrincipalId();
        validator.check(changes[principalId], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _updateRoles(resourceId, changes, callback);
};

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}        resourceId      The resource id.
 * @param  {Object}        changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}      callback        Standard callback function
 * @param  {Object}        callback.err    Error object, containing the error message
 */
var _updateRoles = function(resourceId, changes, callback) {
    var queries = [];
    var roleChanges = _.keys(changes);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        if (changes[principalId]) {
            queries.push({
                'query': 'UPDATE AuthzRoles SET ? = ? WHERE principalId = ?',
                'parameters': [resourceId, changes[principalId], principalId]
            });
            queries.push({
                'query': 'UPDATE AuthzMembers SET ? = ? WHERE resourceId = ?',
                'parameters': [principalId, changes[principalId], resourceId]
            });
        } else if (changes[principalId] === false) {
            queries.push({
                'query': 'DELETE ? FROM AuthzRoles WHERE principalId = ?',
                'parameters': [resourceId, principalId]
            });
            queries.push({
                'query': 'DELETE ? FROM AuthzMembers WHERE resourceId = ?',
                'parameters': [principalId, resourceId]
            });
        } else {
            return callback({'code': 400, 'msg': 'An invalid role has been passed in (undefined)'});
        }
    }
    // Invalidate the AuthzMembershipsCache row for each of the users associated to this resource and each
    // of the users associated to the changes
    if (AuthzUtil.isGroupId(resourceId)) {
        // Collect the userids that need invalidating
        var invalidatedUsers = [];
        var groupsToInvalidate = [];
        var invalidatedGroups = [resourceId];
        
        for (var change in changes) {
            if (AuthzUtil.isUserId(change)) {
                invalidatedUsers.push(change);
            } else if (AuthzUtil.isGroupId(change)) {
                groupsToInvalidate.push(change);
            }
        }
        
        var invalidateGroupMembers = function() {
            if (groupsToInvalidate.length === 0) {
                Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
                    if (err) {
                        return callback(err);
                    }
                    
                    // Invalidate the collected users
                    if (invalidatedUsers.length > 0) {
                        for (var u = 0; u < invalidatedUsers.length; u++) {
                            invalidatedUsers[u] = 'memberships:' + invalidatedUsers[u];
                        }
                        Redis.getClient().del(invalidatedUsers, function(err, response) {
                            callback(err);
                        });
                    } else {
                        callback(err);
                    }
                });
                
            } else {
                var groupId = groupsToInvalidate.shift();
                // Collect all the groups that need to be checked for further invalidation
                getAuthzMembers(groupId, null, 10000, function(err, members) {
                    if (err) {
                        return callback(err);
                    }
                    for (var i = 0; i < members.length; i++) {
                        var memberId = members[i].id;
                        if (AuthzUtil.isUserId(memberId) && !_.contains(invalidatedUsers, memberId)) {
                            invalidatedUsers.push(memberId);
                        } else if (AuthzUtil.isGroupId(memberId) && !_.contains(invalidatedGroups, memberId)) {
                            groupsToInvalidate.push(memberId);
                            invalidatedGroups.push(memberId);
                        }
                    }
                    invalidateGroupMembers();
                });
            }
            
        }
        // Get all of the members of the current group
        invalidateGroupMembers();
        
        
    } else {
        Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    }
};


///////////////////
// AUTHZ MEMBERS //
///////////////////

/**
 * Get all the direct members of a resource and their role on the resource.
 *
 * @param  {String}      resourceId              A unique identifier for a resource. ex: g:cam-oae-team or c:cam:XCDSasD
 * @param  {String}      start                   The principal id that comes just before the first principal you wish to have in your results.
 * @param  {Number}      limit                   The number of members you wish to retrieve.
 * @param  {Function}    callback                Standard callback function
 * @param  {Object}      callback.err            An error that occurred, if any
 * @param  {Object[]}    callback.members        Array of objects for each of the direct member of the resource. Each object has an 'id' key containing
 *                                               the principal id of the member and a 'role' key containing the role of that principal
 */
var getAuthzMembers = module.exports.getAuthzMembers = function(resourceId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided'}).isResourceId();
    validator.check(limit, {code: 400, msg: 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);
    Cassandra.runQuery('SELECT FIRST ' + paging.limit + ' ?..\'\' FROM AuthzMembers USING CONSISTENCY QUORUM WHERE resourceId = ?', [paging.start, resourceId], function (err, rows) {
        if (err) {
            return callback(err);
        }

        var members = [];
        var row = rows[0];
        for (var i = paging.startIndex, j = row.count; i < j; i++) {
            if (row[i].name !== "groupId") {
                members.push({
                    'id': row[i].name,
                    'role': row[i].value
                });
            }
        }

        return callback(false, members);
    });
};

// TODO
var checkGroupMembershipsForUser = function(principalId, groupIds, callback) {
    // Check if the exploded list is there
    Redis.getClient().exists('memberships:' + principalId, function(err, exists) {
        // The memberships have been exploded
        if (exists) {
            Redis.getClient().hmget('memberships:' + principalId, groupIds, function(err, keys) {
                if (err) {
                    return callback(err);
                }
                
                var memberships = [];
                for (var k = 0; k < keys.length; k++) {
                    if (keys[k]) {
                        memberships.push(groupIds[k]);
                    }
                }
                return callback(null, memberships);
            });
        // No exploded memberships found, we need to explode
        } else {
            explodeGroupMemberships(principalId, function(err, allMemberships) {
                if (err) {
                    return callback(err);
                }
                
                var memberships = _.intersection(groupIds, allMemberships);
                return callback(null, memberships);
            });
        }
    });
};

var explodeGroupMemberships = function(principalId, callback) {
    _getAuthzGroupMembershipAncestry(principalId, function(err, memberships) {
        if (err) {
            return callback(err);
        }
        // Publish the memberships into Cassandra
        if (_.keys(memberships).length > 0) {
            Redis.getClient().hmset('memberships:' + principalId, memberships, function(err) {
                if (err) {
                    return callback(err);
                }
                callback(null, _.keys(memberships));
            });
        } else {
            callback(null, []);
        }
    });
};

/**
 * Gets all the Authz groups of which a principal (either user or group) is a member. This includes all group ancestors to 
 * which the user is indirectly a member.
 *
 * @param  {String}           principalId             The principal id for which to retrieve all the group memberships
 * // TODO
 * @param  {Function}         callback                Standard callback function
 * @param  {Object}           callback.err            An error that occured, if any
 * @param  {String[]}         callback.groups         An (inconsistently ordered) array of groups to which the user belongs, either directly or indirectly
 */
var getPrincipalMemberships = module.exports.getPrincipalMemberships = function(principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {code: 400, msg: 'Invalid principal id provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Page the query.
    var paging = Cassandra.getPagingParameters(start, limit);
    // Get the memberships from the cached row
    Redis.getClient().hkeys(principalId, function(err, keys) {
        if (keys.length > 0) {
            return callback(false, keys.slice(0, limit));
        } else {
            explodeGroupMemberships(principalId, function(err, allMemberships) {
                if (err) {
                    return callback(err);
                }
                
                var startIndex = 0;
                if (start) {
                    startIndex = _.indexOf(allMemberships, start);
                }
                var memberships = allMemberships.slice(start, start + limit);
                return callback(false, memberships);
            });    
        }
    });
};

/**
 * Given some principal, get their entire group membership ancestry. In other words, get all the groups to which they belong,
 * and the groups to all those groups belong, and so on.
 *
 * @param   {String}        principalId         The principal id for which to retrieve the authz group membership ancestry
 * @param   {Function}      callback            Standard callback function
 * @param   {Object}        callback.err        The err that occured, if any
 * 
 * @param   {Object}        callback.ancestry   A hash keyed by the group id of each group of which the user is indirectly a member. The value of each entry is `true`.
 */
var _getAuthzGroupMembershipAncestry = function(principalId, callback) {
    var results = {};

    var _multiGetAuthzGroupMembershipAncestry = function(principalIds, results) {
        getRolesForPrincipalsAndResourceType(principalIds, AuthzConstants.resourceTypes.GROUP, 10000, function(err, entries) {
            if (err) {
                return callback(err);
            }

            var nextPrincipalBatch = [];
            var ancestors = _.keys(entries);
            // for each group parent, determine if we've already recorded their membership. if not, we record it, and search it's parents
            for (var i = 0; i < ancestors.length; i++) {
                var ancestorId = ancestors[i];
                if (!results[ancestorId]) {
                    results[ancestorId] = 'true';
                    nextPrincipalBatch.push(ancestorId);
                }
            }

            // if we found new ancestors, we need to recurse to find their ancestors. Otherwise we're done.
            if (nextPrincipalBatch.length > 0) {
                return _multiGetAuthzGroupMembershipAncestry(nextPrincipalBatch, results);
            } else {
                return callback(false, results);
            }
        });
    };

    _multiGetAuthzGroupMembershipAncestry([principalId], results, callback);
};

/**
 * Get all principal roles associated to the resourceType for all the principals in the array of principal ids. This can be performed on 
 * multiple principals at once.
 * 
 * The structure of the resulting entries is structured a hash, indicating all resource ids that were returned and what the
 * roles associated to those resources were. For example:
 *
 *     {
 *      'u:cam:simong': { 'member': true },
 *      'g:cam:group-b': { 'member': true }
 *     }
 *
 * or:
 *
 *     {
 *      'c:gat:Foo.docx': { 'viewer': true, 'manager': true},
 *      'c:cam:Bar.pdf':  { 'viewer': true }
 *     }
 *
 * In the latter case, 'c:gat:Foo.docx' has both 'viewer' and 'manager' role associated to it. This indicates that some principal
 * had a role of 'viewer' on the resource, while some other principal had the 'manager' role.
 *
 * @param  {Array}          principalIds        The array of principal ids to query for
 * @param  {String}         resourceType        The resource type of the resources to search for, as determined by Resource.resourceType
 * @param  {Number}         limit               The maximum number of resources to return per user
 * @param  {Function}       callback            A function providing all the {resource id} -> {roles} mappings aggregated for all the provided principals queried
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Object}         callback.entries    A JSON Object representing the roles associated to the users
 */
var getRolesForPrincipalsAndResourceType = module.exports.getRolesForPrincipalsAndResourceType = function(principalIds, resourceType, limit, callback) {
    limit = limit || 1000;
    principalIds = principalIds || [];

    var validator = new Validator();
    validator.check(limit, {code: 400, msg: '"limit" parameter must be a number when searching for active roles'});
    validator.check(resourceType, {code: 400, msg: 'A resourceType needs to be provided'}).notEmpty();
    validator.check(principalIds.length, {code: 400, msg: 'At least one principal Id needs to be passed in'}).min(1);
    for (var i = 0; i < principalIds.length; i++) {
        var principalId = principalIds[i];
        validator.check(principalId, {code: 400, msg: 'Invalid principal id specified: ' + principalId}).isPrincipalId();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // we append a '|' to the "end" range, as | has a high ASCII alphabetical ordering. This may not suffice if resourceIds have
    // multi-byte characters, which is technically possible. Unfortunately, I don't think there is a better way to do this with
    // CQL.
    var start = resourceType + ':';
    var end = start + '|';

    var cql = 'SELECT FIRST ' + limit + ' ? .. ? FROM AuthzRoles USING CONSISTENCY QUORUM WHERE principalId IN (?)';
    Cassandra.runQuery(cql, [start, end, principalIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var entries = {};

        // Aggregate all resources from all the rows (principals) into the entries hash
        var expandRow = function(name, value) {
            if (!entries[name]) {
                entries[name] = {};
            }
            entries[name][value] = true;
        };
        for (var i = 0; i < rows.length; i++) {
            rows[i].forEach(expandRow);
        }
        
        callback(null, entries);
    });
};

/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');
var Neo4J = require('oae-util/lib/neo4j');
var Telemetry = require('oae-telemetry').telemetry('authz');
var Validator = require('oae-authz/lib/validator').Validator;
var AuthzUtil = require('oae-authz/lib/util');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;

/////////////////////////
// ROLES & PERMISSIONS //
/////////////////////////

/**
 * Determine the direct role assigned to a principal on a specified resource.
 * 
 * @param  {String}     principalId     The principal id. This can be a user or a group
 * @param  {String}     resourceId      The resource id. This can be a group as well.
 * @param  {Function}   callback        Standard callback function 
 * @param  {Object}     callback.err    An error that occurred, if any.
 * @param  {String}     callback.role   The role of the principal on the resource. If the principal has no role or there is an error performing the check, role will be null.
 */
var _getDirectRole = function(principalId, resourceId, callback) {
    var principalType = principalId.split(':')[0];
    var resourceType = resourceId.split(':')[0];
    var cypher = 'START a=node:' + principalType + '(uid="' + principalId + '"), b=node:' + resourceType + '(uid="' + resourceId + '") MATCH a-[r]->b RETURN r';
    Neo4J.getNeo4JDB().query(cypher, {}, function(err, result) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        } else if (result) {
            return callback(null, result[0].r.type);
        } else {
            return callback(null, null);
        }
    });
};

/**
 * Given a principal and a resource, determine all the effective roles that the principal has on the resource, by virtue of direct
 * association and indirect group inheritance.
 *
 * @param  {String}       principalId       The principal id. This can be a user or a group
 * @param  {String}       resourceId        The resource id. This can be a group as well.
 * @param  {Function}     callback          Standard callback function
 * @param  {Object}       callback.err      An error that occurred, if any
 * @param  {String[]}     callback.roles    An array containing all the roles the principal has on the resource.
 */
var getAllRoles = module.exports.getAllRoles = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {code: 400, msg: 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var principalType = principalId.split(':')[0];
    var resourceType = resourceId.split(':')[0];
    var cypher = 'START a=node:' + principalType + '(uid="' + principalId + '"), b=node:' + resourceType + '(uid="' + resourceId + '") MATCH path = a-[r*..10]->b RETURN r, path';
    Neo4J.getNeo4JDB().query(cypher, {}, function(err, result) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        var allRoles = [];
        for (var i = 0; i < result.length; i++) {
            var role = result[i].r[result[i].r.length - 1].type;
            if (!_.contains(allRoles, role)) {
                allRoles.push(role);
            }
        }
        callback(null, allRoles);
    });
};

/**
 * Determines whether or not a principal has the specified role directly or indirectly on a given resource.
 * 
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {String}      role                The role to check
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has the specified role on the resource
 */
var hasRole = module.exports.hasRole = function(principalId, resourceId, role, callback) {
    var validator = new Validator();
    validator.check(principalId, {code: 400, msg: 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided.'}).isResourceId();
    validator.check(role, {code: 400, msg: 'Invalid role provided.'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var principalType = principalId.split(':')[0];
    var resourceType = resourceId.split(':')[0];
    var cypher = 'START a=node:' + principalType + '(uid="' + principalId + '"), b=node:' + resourceType + '(uid="' + resourceId + '") MATCH path = a-[*0..10]->()-[:' + role + ']->b RETURN path';
    
    Neo4J.getNeo4JDB().query(cypher, {}, function(err, result) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        } else if (result) {
            return callback(null, true);
        } else {
            return callback(null, false);
        }
    });
};

/**
 * Determines whether or not a principal has any role directly or indirectly on a given resource.
 * 
 * @param  {String}      principalId         The principal id. This can be a user or a group.
 * @param  {String}      resourceId          The resource id. This can be a group as well
 * @param  {Function}    callback            A function specifying whether or not the user has the role on the resource
 * @param  {Object}      callback.err        An error that occurred, if any
 * @param  {Boolean}     callback.hasRole    Whether or not the principal has a role on the resource
 */
var hasAnyRole = module.exports.hasAnyRole = function(principalId, resourceId, callback) {
    var validator = new Validator();
    validator.check(principalId, {code: 400, msg: 'Invalid principal id provided.'}).isPrincipalId();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided.'}).isResourceId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var principalType = principalId.split(':')[0];
    var resourceType = resourceId.split(':')[0];
    var cypher = 'START a=node:' + principalType + '(uid="' + principalId + '"), b=node:' + resourceType + '(uid="' + resourceId + '") MATCH path = a-[*..10]->b RETURN path';
    Neo4J.getNeo4JDB().query(cypher, {}, function(err, result) {
        console.log(principalType);
        console.log(principalId);
        console.log(resourceType);
        console.log(resourceId);
        console.log('RESULTSRESULTS --> ' + result);
        console.log('RESULTSRESULTS --> ' + err);
        if (err) {
            return callback({'code': 500, 'msg': err});
        } else if (result) {
            return callback(null, true);
        } else {
            return callback(null, false);
        }
    });
};

/**
 * Assign one or multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}          resourceId      The resource id.
 * @param  {Object}          changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}        callback        Standard callback function
 * @param  {Object}          callback.err    Error object, containing the error message
 */
var updateRoles = module.exports.updateRoles = function(resourceId, changes, callback) {
    var validator = new Validator();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided.'}).isResourceId();
    var roleChanges = _.keys(changes);
    validator.check(roleChanges.length, {code: 400, msg: 'At least one role change needs to be applied'}).min(1);
    for (var i = 0; i < roleChanges.length; i++) {
        var principalId = roleChanges[i];
        validator.check(principalId, {code: 400, msg: 'Invalid principal id specified: ' + principalId}).isPrincipalId();
        validator.check(changes[principalId], {code: 400, msg: 'Invalid role provided.'}).isValidRoleChange();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _updateRoles(resourceId, changes, callback);
};

/**
 * Assign multiple principals a role on a resource instance. If the user already has a role, it will simply be updated. When
 * false is passed in as a role, the role for that principal will be removed.
 *
 * @param  {String}        resourceId      The resource id.
 * @param  {Object}        changes         JSON object where the keys are principal ids and the values are role values
 * @param  {Function}      callback        Standard callback function
 * @param  {Object}        callback.err    Error object, containing the error message
 */
var _updateRoles = function(resourceId, changes, callback) {
    console.log(_.keys(changes).length);
    var todo = _.keys(changes).length;
    var done = 0;
    
    var finishRole = function(err) {
        if (err) {
            console.log(err);
        }
        done++;
        console.log(todo + ' - ' + done);
        if (todo === done) {
            console.log('WE ARE DONE');
            callback(null);
        }
    };
    
    for (var c in changes) {
        console.log(c);
        if (changes[c] === false) {
            Neo4J.deleteRelationship(c, resourceId, finishRole);
        } else {
            Neo4J.upsertRelationship(c, resourceId, changes[c], finishRole);
        }
    }
};


///////////////////
// AUTHZ MEMBERS //
///////////////////

/**
 * Get all the direct members of a resource and their role on the resource.
 *
 * @param  {String}      resourceId              A unique identifier for a resource. ex: g:cam-oae-team or c:cam:XCDSasD
 * @param  {String}      start                   The principal id that comes just before the first principal you wish to have in your results.
 * @param  {Number}      limit                   The number of members you wish to retrieve.
 * @param  {Function}    callback                Standard callback function
 * @param  {Object}      callback.err            An error that occurred, if any
 * @param  {Object[]}    callback.members        Array of objects for each of the direct member of the resource. Each object has an 'id' key containing
 *                                               the principal id of the member and a 'role' key containing the role of that principal
 */
var getAuthzMembers = module.exports.getAuthzMembers = function(resourceId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(resourceId, {code: 400, msg: 'Invalid resource id provided'}).isResourceId();
    validator.check(limit, {code: 400, msg: 'The limit parameter needs to be a number'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var resourceType = resourceId.split(':')[0];
    var cypher = 'START a=node:' + resourceType + '(uid="' + resourceId + '") MATCH path = a<-[r]-b RETURN r,b';
    Neo4J.getNeo4JDB().query(cypher, {}, function(err, result) {
        if (result) {
            var memberships = [];
            for (var i = 0; i < result.length; i++) {
                memberships.push({
                    'id': result[i].b.data.uid,
                    'role': result[i].r.type
                });
            }
            callback(null, memberships);
        } else {
            callback(null, []);
        }
    });
};

/**
 * Gets all the Authz groups of which a principal (either user or group) is a member. This includes all group ancestors to 
 * which the user is indirectly a member.
 *
 * @param  {String}           principalId             The principal id for which to retrieve all the group memberships
 * // TODO
 * @param  {Function}         callback                Standard callback function
 * @param  {Object}           callback.err            An error that occured, if any
 * @param  {String[]}         callback.groups         An (inconsistently ordered) array of groups to which the user belongs, either directly or indirectly
 */
var getPrincipalMemberships = module.exports.getPrincipalMemberships = function(principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {code: 400, msg: 'Invalid principal id provided'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var principalType = principalId.split(':')[0];
    var cypher = 'START a=node:' + principalType + '(uid="' + principalId + '") MATCH path = a-[*..10]->b WHERE b.type="g" RETURN b';
    Neo4J.getNeo4JDB().query(cypher, {}, function(err, result) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }
        var memberships = [];
        for (var i = 0; i < result.length; i++) {
            memberships.push(result[i].b.data.uid);
        }
        callback(null, memberships);
    });
};

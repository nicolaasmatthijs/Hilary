/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var dox = require('dox');
var fs = require('fs');
var path = require('path');

var IO = require('oae-util/lib/io');
var Modules = require('oae-util/lib/modules');
var Validator = require('oae-util/lib/validator').Validator;
var UIAPI = require('oae-ui');
var log = require('oae-logger').logger('oae-doc');

// Variable that will be used to cache the back-end and front-end documentation
var cachedDocs = {
    'backend': {},
    'frontend': {}
};

/**
 * Initializes the docs by fetching all the back-end modules and front-end APIs, parsing
 * their documentation and caching it.
 *
 * @param  {Object}     uiPath           The path to the UI directory
 * @param  {Function}   callback         Standard callback function
 */
var initializeDocs = module.exports.initializeDocs = function(uiPath, callback) {
    // Initialize the front-end documentation
    initializeFrontendDocs(uiPath, callback);
};

/**
 * Initialize the front-end docs by fetching the list of available API files, parsing
 * their documentation and caching it.
 *
 * @param  {Object}     uiPath           The path to the UI directory
 * @param  {Function}   callback         Standard callback function
 * @api private
 */
var initializeFrontendDocs = function(uiPath, callback) {
    var exclude = ['oae.api.js', 'oae.bootstrap.js', 'oae.core.js'];
    // Only parse the API files. We don't parse any other UI files yet.
    parseDocs(uiPath, '/shared/oae/api', exclude, function(err, docs) {
        cachedDocs.frontend = docs;
        // Initialize the back-end documentation
        initializeBackendDocs(callback);
    });
};

/**
 * Initialize the back-end docs by fetching the list of available modules, parsing
 * the documentation of the files in `/lib` and caching it.
 *
 * @param  {Function}   callback         Standard callback function
 * @api private
 */
var initializeBackendDocs = function(callback) {
    var modules = Modules.getAvailableModules();
    var done = 0;

    _.each(modules, function(module) {
        // Parse the JS files in /lib for each module
        var dir = 'node_modules/' + module + '/lib';
        parseDocs('', dir, null, function(err, docs) {
            done++;
            cachedDocs.backend[module] = docs;
            if (done === modules.length) {
                callback();
            }
        });
    });
};

/**
 * Parse the JSDocs of all of the JavaScript files in a directory into a JSON object,
 * using Dox (https://github.com/visionmedia/dox).
 *
 * @param  {String}     basePath        
 * @param  {String}     dir             The path to the directory relative to the basePath in which we want to parse the JSDocs
 * @param  {String[]}   [exclude]       List of filenamesthat should be excluded from the parsing
 * @param  {Function}   [callback]      Standard callback function
 * @param  {Object}     [callback.err]  Error object containing error code and error message 
 * @param  {Object}     [callback.docs] JSON Object where the keys are the file names and the values are the parsed JSDocs
 * @api private
 */
var parseDocs = function(basePath, dir, exclude, callback) {
    // Get all of the files in the provided base directory
    IO.getFileListForFolder(basePath + dir, function(err, fileNames) {
        if (err) {
            log().warn({'err': err, 'dir': dir}, 'Failed getting file list to parse dox documentation.');
            return callback({'code': 404, 'msg': 'No documentation for this module was found'});
        }

        // Map any hashes files to their original filename for readability purposes
        var mappedFiles = mapHashedFiles(fileNames, dir);

        // Filter out all non-javascript and excluded files
        mappedFiles = filterFiles(mappedFiles, exclude);

        var done = 0;
        var todo = _.keys(mappedFiles).length;
        var doc = {};

        _.each(mappedFiles, function(path, fileName) {
            (function(path, fileName) {
                // Read each of the files in the provided directory
                IO.readFile(basePath + path, function(err, data) {
                    done++;
                    if (!err) {
                        // Parse the JSDocs using Dox
                        try {
                            doc[fileName] = dox.parseComments(data);
                        } catch (ex) {
                            log().warn({
                                err: ex,
                                data: data
                            }, 'Failed parsing comment data with dox for file %s. Ignoring.', dir + '/' + fileName);
                        }
                    } else {
                        log().error('Failed reading ' + dir + '/' + fileName);
                    }

                    if (done === todo) {
                        return callback(err, doc);
                    }
                });
            })(path, fileName);
        });

        if (!fileNames.length) {
            callback({'code': 404, 'msg': 'No documentation for this module was found'});
        }
    });
};

/**
 * Utility function that will try to map a list of files inside of a folder to the original unhashed version.
 * The unhashed version can then be used for generating more user-readable names and filtering based on filenames.
 *
 * @param  {String[]}   fileNames           The unfiltered array of filenames that needs to be mapped
 * @param  {String}     dir                 The base path to the folder containing the provided filenames
 * @return {Object}                         JSON object where the keys are the user-friendly filenames and the values are the actual paths to these file. These paths will be hasehd when working with a production build.
 * @api private
 */
var mapHashedFiles = function(fileNames, dir) {
    var mappedFiles = {};
    _.each(fileNames, function(fileName) {
        // TODO
        var path = dir + '/' + fileName;
        var mappedPath = UIAPI.getOriginalResource(path) || path;
        mappedFiles[mappedPath.split('/').pop()] = path;
    });
    return mappedFiles;
};

/**
 * Utility function that filters out all non-javascript files, folders and all excluded files, 
 * as we don't want to  generate documentation for these.
 *
 * @param  {Object}     mappedFiles         JSON object where the keys are the user-friendly filenames and the values are the actual paths to these file. These paths will be hasehd when working with a production build.
 * @param  {String[]}   [exclude]           Array of filenames that should be filtered out
 * @return {Object}                         Object in which the non-javascript and other excluded files are stripped
 * @api private
 */
var filterFiles = function(mappedFiles, exclude) {
    _.each(mappedFiles, function(path, fileName) {
        if (fileName.indexOf('.js') === -1 || _.indexOf(exclude, fileName) !== -1) {
            delete mappedFiles[fileName];
        }
    });
    return mappedFiles;
};

/**
 * Retrieve the list of available modules
 *
 * @param  {String}     type                The module type to get the listing for. Accepted values are `backend` and `frontend`
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing the error code and message
 * @param  {String[]}   callback.modules    The list of available modules for the provided type
 */
var getModules = module.exports.getModules = function(type, callback) {
    if (!cachedDocs[type]) {
        return callback({'code': 400, 'msg': 'Invalid module type. Accepted values are "backend" and "frontend"'});
    }

    callback(null, _.keys(cachedDocs[type]));
}

/**
 * Retrieve the documentation for a particular module
 * 
 * @param  {String}     moduleId        The module to get the documentation for
 * @param  {String}     type            The type of the module to get the documentation for. Accepted values are `backend` and `frontend`
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Error object containing the error code and message
 * @param  {Object}     callback.doc    The parsed documentation for the requested module
 */
var getModuleDocumentation = module.exports.getModuleDocumentation = function(moduleId, type, callback) {
    var validator = new Validator();
    validator.check(moduleId, {'code': 400, 'msg': 'Missing module id'}).notEmpty();
    validator.check(type, {'code': 400, 'msg': 'Missing module type'}).notEmpty();
    validator.check(type, {'code': 400, 'msg': 'Invalid module type. Accepted values are "backend" and "frontend"'}).isIn(['backend', 'frontend']);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Return the parsed docs from cache
    if (cachedDocs[type] && cachedDocs[type][moduleId]) {
        return callback(null, cachedDocs[type][moduleId]);
    } else {
        return callback({'code': 404, 'msg': 'No documentation for this module was found'});
    }
};

